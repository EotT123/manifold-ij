<idea-plugin>
  <id>manifold.ij</id>
  <name>Manifold</name>
  <description>
    <![CDATA[
<h2><a href="#what-is-manifold" id="what-is-manifold">What is Manifold?</a></h2>
<p><a href="http://manifold.systems">Manifold</a> re-energizes Java with powerful features like Type-safe Metaprogramming, Structural Typing, and Extension Methods.
Simply add the Manifold jar to your project and begin taking advantage of it.</p>
<h2><a href="#what-can-you-do-with-manifold" id="what-can-you-do-with-manifold">What can you do with Manifold?</a></h2>
<h3><a href="#meta-programming" id="meta-programming"><a href="http://manifold.systems/docs.html#manifold-in-a-nutshell">Meta-programming</a></a></h3>
<p>Use the framework to gain direct, type-safe access to <i>any</i> type of metadata, such as GraphQL, JSON Schema, YAML, and Javascript. Remove the code gen step in your build process.</p>
<pre><code class="java">// Use your User.json schema file directly as a type, no code gen!
User user = User.builder(&quot;myid&quot;, &quot;mypassword&quot;, &quot;Scott&quot;)
  .withGender(male)
  .withDob(LocalDate.of(1987, 6, 15))
  .build();
User.request(&quot;htt://api.example.com/users&quot;).postOne(user);
</code></pre>
<h3><a href="#extensions" id="extensions"><a href="http://manifold.systems/docs.html#the-extension-manifold">Extensions</a></a></h3>
<p>Add extension methods to existing Java classes, even String, List, and File. Eliminate boilerplate code. <a href="http://manifold.systems/images/ExtensionMethod.mp4">Check it out!</a></p>
<pre><code class="java">String greeting = &quot;hello&quot;;
greeting.myMethod(); // Add your own methods to String!
</code></pre>
<h3><a href="#structural-typing" id="structural-typing"><a href="http://manifold.systems/docs.html#structural-interfaces">Structural Typing</a></a></h3>
<p>Unify disparate APIs. Bridge software components you do not control. Access maps through type-safe interfaces.</p>
<pre><code class="java">Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
MyThingInterface thing = (MyThingInterface) map; // O_o
thing.setFoo(new Foo());
Foo foo = thing.getFoo();
out.println(thing.getClass()); // prints &quot;java.util.HashMap&quot;
</code></pre>
<h3><a href="#type-safe-reflection" id="type-safe-reflection"><a href="http://manifold.systems/docs.html#type-safe-reflection">Type-safe Reflection</a></a></h3>
<p>Access private features with <b>@Jailbreak</b> to avoid the drudgery and vulnerability of Java reflection.</p>
<pre><code class="java">@Jailbreak Foo foo = new Foo();
// Direct, *type-safe* access to *all* foo's members
foo.privateMethod(x, y, z);
foo.privateField = value;
</code></pre>
<h3><a href="#checked-exception-suppression" id="checked-exception-suppression"><a href="http://manifold.systems/docs.html#checked-exception-suppression">Checked Exception Suppression</a></a></h3>
<p>Simply add the <code>exceptions</code> plugin argument: <code>-Xplugin:Manifold strings</code><em><code>exceptions</code></em>. Now checked exceptions
behave like unchecked exceptions!  No more compiler errors, no more boilerplate <code>try</code>/<code>catch</code> nonsense.</p>
<pre><code class="java">List&lt;String&gt; strings = ...;
List&lt;URL&gt; urls = list
  .map(URL::new) // No need to handle the MalformedURLException!
  .collect(Collectors.toList());
</code></pre>
<h3><a href="#string-templates-aka-string-interpolation" id="string-templates-aka-string-interpolation"><a href="http://manifold.systems/docs.html#templating">String Templates</a> (aka String Interpolation)</a></h3>
<p>Embed variables and expressions in String literals, no more clunky string concat!</p>
<pre><code class="java">int hour = 15;
// Simple variable access with '$'
String result = &quot;The hour is $hour&quot;; // Yes!!!
// Use expressions with '${}'
result = &quot;It is ${hour &gt; 12 ? hour-12 : hour} o'clock&quot;;
</code></pre>
<h3><a href="#template-files-with-mantl" id="template-files-with-mantl"><a href="http://manifold.systems/manifold-templates.html">Template Files with <em>ManTL</em></a></a></h3>
<p>Author template files with the full expressive power of Java, use your templates directly in your code as types.</p>
<pre><code class="java">List&lt;User&gt; users = ...;
String content = abc.example.UserSample.render(users);
</code></pre>
<p>A tempate file <code>abc/example/UserSample.html.mtl</code></p>
<pre><code class="html">&lt;%@ import java.util.List %&gt;
&lt;%@ import com.example.User %&gt;
&lt;%@ params(List&lt;User&gt; users) %&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
&lt;% users.stream()
   .filter(user -&gt; user.getDateOfBirth() != null)
   .forEach(user -&gt; { %&gt;
    User: ${user.getName()} &lt;br&gt;
    DOB: ${user.getDateOfBirth()} &lt;br&gt;
&lt;% }); %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3><a href="#libraries" id="libraries"><a href="http://manifold.systems/docs.html#extension-libraries">Libraries</a></a></h3>
<p>Leverage stock Manifold extension libraries for standard Java classes. Save time and reduce boilerplate code.</p>
<pre><code class="java">File file = new File(path);
// Use refreshing extensions to File
String content = file.readText();
</code></pre>
<h3><a href="#intellij" id="intellij"><a href="http://manifold.systems/docs.html#working-with-intellij">IntelliJ</a></a></h3>
<p>Use the Manifold IntelliJ IDEA plugin to fully leverage Manifold in your development cycle. The plugin provides
comprehensive support for IntelliJ features including code completion, navigation, usage searching, refactoring,
incremental compilation, hotswap debugging, full-featured template editing, and more.</p>
<h3><a href="#learn-more" id="learn-more"><a href="http://manifold.systems/docs.html">Learn More</a></a></h3>
    ]]>
  </description>
  <version>This value is patched by the build script</version>
  <vendor email="admin@manifold.systems" url="http://manifold.systems">manifold.systems</vendor>
  <!-- please see http://confluence.jetbrains.com/display/IDEADEV/Build+Number+Ranges for description -->
  <idea-version since-build="This value is patched by the build script"/>

  <change-notes>
    <![CDATA[
Big fixes & Early access release preparation<br>
- Fix some JPMS related issues with multi-module projects
- Early access release preparation, and preparation for JetBrains Marketplace
     ]]>
  </change-notes>
  
  <actions>
    <group id="Manifold.New">
      <action id="Manifold.NewExtensionClass" class="manifold.ij.actions.CreateExtensionMethodsClassAction"/>
      <action id="Manifold.NewTemplate" class="manifold.ij.actions.CreateManifoldTemplateAction"/>
      <add-to-group group-id="NewGroup1" anchor="last"/>
    </group>
    <group id="Manifold.SourceCode">
      <action class="manifold.ij.actions.ViewJavaSourceAction"/>
      <add-to-group group-id="ViewMenu" anchor="after" relative-to-action="QuickActions"/>
    </group>
  </actions>

  <application-components>
    <component>
      <implementation-class>manifold.ij.core.ManApplicationComponent</implementation-class>
    </component>
  </application-components>

  <project-components>
    <component>
      <implementation-class>manifold.ij.core.ManProjectComponent</implementation-class>
    </component>
  </project-components>

  <extensions defaultExtensionNs="com.intellij">
    <repositoryLibrary name="Manifold">
      <groupId>systems.manfold</groupId>
      <artifactId>manifold-all</artifactId>
    </repositoryLibrary>


    <!-- Manifold Core extensions -->

    <!--<projectService serviceInterface="com.intellij.psi.impl.ResolveScopeManager"-->
                    <!--serviceImplementation="manifold.ij.extensions.ManResolveScopeManagerImpl" overrides="true"/>-->
    <projectService serviceInterface="com.intellij.psi.search.PsiSearchHelper"
                    serviceImplementation="manifold.ij.extensions.ManPsiSearchHelperImpl" overrides="true"/>

    <projectService serviceInterface="com.intellij.psi.PsiResolveHelper"
                    serviceImplementation="manifold.ij.extensions.ManPsiResolveHelperImpl" overrides="true"/>
    <projectService serviceInterface="com.intellij.psi.impl.source.resolve.ResolveCache"
                    serviceImplementation="manifold.ij.extensions.ManResolveCache" overrides="true"/>

    <!--<library.type implementation="manifold.ij.extensions.ManLibraryType"/>-->
    <frameworkSupport implementation="manifold.ij.extensions.ManSupportProvider"/>
    <framework.type implementation="manifold.ij.extensions.ManFrameworkType"/>
    <java.elementFinder implementation="manifold.ij.extensions.ManTypeFinder" order="first, before java"/>
    <java.shortNamesCache implementation="manifold.ij.extensions.ManShortNamesCache"/>
    <gotoDeclarationHandler implementation="manifold.ij.extensions.ManGotoDeclarationHandler"/>
    <lang.psiAugmentProvider implementation="manifold.ij.extensions.ManAugmentProvider"/>
    <methodReferencesSearch implementation="manifold.ij.extensions.ExtensionMethodUsageSearcher"/>
    <annotator language="JAVA" implementationClass="manifold.ij.extensions.ExtensionClassAnnotator"/>
    <annotator language="JAVA" implementationClass="manifold.ij.extensions.ExtensionMethodCallSiteAnnotator"/>
    <annotator language="JAVA" implementationClass="manifold.ij.extensions.SelfUsageAnnotator"/>
    <annotator language="JAVA" implementationClass="manifold.ij.extensions.JailbreakUsageAnnotator"/>
    <annotator language="JAVA" implementationClass="manifold.ij.extensions.MiscAnnotator"/>
    <daemon.highlightInfoFilter implementation="manifold.ij.extensions.ManHighlightInfoFilter"/>
    <renamePsiElementProcessor implementation="manifold.ij.extensions.RenameTypeManifoldFileProcessor" order="first"/>
    <moveFileHandler implementation="manifold.ij.extensions.MoveTypeManifoldFileProcessor" order="first"/>
    <findUsagesHandlerFactory implementation="manifold.ij.extensions.ManifoldFindUsagesHandlerFactory" order="first"/>
    <lang.findUsagesProvider language="TEXT" implementationClass="manifold.ij.extensions.TextFindUsagesProvider"/>
    <renameHandler implementation="manifold.ij.extensions.ManRenameHandler" order="first"/>
    <renamePsiElementProcessor implementation="manifold.ij.extensions.RenameResourceElementProcessor" order="first"/>
    <renamePsiElementProcessor implementation="manifold.ij.extensions.RenameExtensionMethodProcessor" order="first"/>
    <nameSuggestionProvider implementation="manifold.ij.extensions.ManNameSuggestionProvider" order="first"/>
    <resolveScopeEnlarger implementation="manifold.ij.extensions.ManResolveScopeProvider" order="first"/>
    <elementDescriptionProvider implementation="manifold.ij.extensions.ManElementDescriptionProvider"/>
    <languageInjector implementation="manifold.ij.extensions.ManStringLiteralTemplateInjector" order="first"/>
    <implicitUsageProvider implementation="manifold.ij.extensions.ManStringLiteralTemplateUsageProvider"/>
    <targetElementEvaluator language="TEXT" implementationClass="manifold.ij.extensions.ManTextElementEvaluator"/>
    <completion.contributor language="JAVA" implementationClass="manifold.ij.extensions.ManJavaCompletionContributor" order="first"/>

    <!-- ManJavaSyntaxHighlighterFactory exists solely so we can include '$' as an escapable for String literal templates
         see ManJavaFileHighlighter -->
    <lang.syntaxHighlighterFactory language="JAVA" implementationClass="manifold.ij.extensions.ManJavaSyntaxHighlighterFactory" order="first"/>

    <!-- This enables the ManBuilderService and dynamically configures the classpath (includes manifold-jps-plugin.jar etc.) -->
    <buildProcess.parametersProvider implementation="manifold.ij.jps.ManBuildClasspathProvider"/>
    <compileServer.plugin classpath=""/>

    <!-- Manifold Template extensions -->

    <fileTypeFactory implementation="manifold.ij.template.ManTemplateFileTypeFactory"/>
    <lang.parserDefinition language="ManTemplateJava" implementationClass="manifold.ij.template.psi.ManTemplateJavaParserDefinition"/>
    <lang.treePatcher language="ManTemplateJava" implementationClass="manifold.ij.template.ManTreePatcher"/>
    <lang.parserDefinition language="ManTL" implementationClass="manifold.ij.template.psi.ManTemplateParserDefinition"/>
    <lang.syntaxHighlighterFactory language="ManTL" implementationClass="manifold.ij.template.ManTemplateHighlighterFactory"/>
    <lang.fileViewProviderFactory language="ManTL" implementationClass="manifold.ij.template.ManTemplateFileViewProviderFactory" order="first"/>
    <annotator language="ManTL" implementationClass="manifold.ij.template.ManTemplateAnnotator"/>
    <annotator language="JAVA" implementationClass="manifold.ij.template.ManTemplateJavaAnnotator"/>
    <daemon.highlightInfoFilter implementation="manifold.ij.template.ManTemplateHighlightInfoFilter"/>
    <colorSettingsPage implementation="manifold.ij.template.ManTemplateColorSettingsPage"/>
    <lang.commenter language="ManTL" implementationClass="manifold.ij.template.ManTemplateCommenter"/>
    <typedHandler implementation="manifold.ij.template.ManTemplateTypedHandler"/>
    <enterHandlerDelegate implementation="manifold.ij.template.psi.ManTemplateEnterHandler"/>
  </extensions>

</idea-plugin>
